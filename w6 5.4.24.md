
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0
int getMaxInt(int *tab,unsigned int size);
double getMaxDoubles(double *tab,int size);
int main(void)
{
    int tabOfInts[]={3,2,1,5,6,4};
    double tabOfDoubles[]={3.3,2.2,1.1,5.5,6.6,4.4};
    printf("max=%d\n", getMaxInt(tabOfInts,6));
    printf("max=%f\n", getMaxDoubles(tabOfDoubles,6));

    return EXIT_SUCCESS;
}

int getMaxInt(int *tab,unsigned int size)
{
    int i;
    int max=tab[0];
    for(i=1;i<size;i++)
    {
        if(tab[i]>max)
        {
            max=tab[i];
        }
    }
    return max;
}
double getMaxDoubles(double *tab,int size)
{
    int i;
    double max=tab[0];
    for(i=1;i<size;i++)
    {
        if(tab[i]>max)
        {
            max=tab[i];
        }
    }
    return max;
}

# =============================================================================================
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0
enum argumentType {INT,DOUBLE};

void getMax(void *tabPoly,unsigned int size, enum argumentType);
int main(void)
{
    int tabOfInts[]={3,2,1,5,6,4};
    double tabOfDoubles[]={3.3,2.2,1.1,5.5,6.6,4.4};
    getMax(tabOfInts,6,INT);
    getMax(tabOfDoubles,6,DOUBLE);

    return EXIT_SUCCESS;
}

void getMax(void *tabPoly,unsigned int size, enum argumentType type)
{
    int i;
    if (type ==INT)
    {
        int *tab=(int*)tabPoly;
        int max=tab[0];
        for(i=1;i<size;i++)
    {
        if(tab[i]>max)
        {
            max=tab[i];
        }
    }
    printf("max=%d\n",max);
    }else if (type ==DOUBLE)
    {
        double *tab=(double*)tabPoly;
        double max=tab[0];
        for(i=1;i<size;i++)
    {
        if(tab[i]>max)
        {
            max=tab[i];
        }
    }
    printf("max=%f\n",max);
    }
  
}
=============================================================================================================
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0
enum argumentType {INT,DOUBLE};

struct polyType
{
    int i;
    double d;
};
struct polyType getMax(void *tabPoly,unsigned int size, enum argumentType);
int main(void)
{
    int tabOfInts[]={3,2,1,5,6,4};
    double tabOfDoubles[]={3.3,2.2,1.1,5.5,6.6,4.4};
    struct polyType result1, result2;
    result1=getMax(tabOfInts,6,INT);
    result2=getMax(tabOfDoubles,6,DOUBLE);
    printf("max=%d, max= %f",result1.i,result2.d);
    return EXIT_SUCCESS;
}

struct polyType getMax(void *tabPoly,unsigned int size, enum argumentType type)
{
    int i;
    struct polyType result;
    
    if (type ==INT)
    {
        int *tab=(int*)tabPoly;
        int max=tab[0];
        for(i=1;i<size;i++)
    {
        if(tab[i]>max)
        {
            max=tab[i];
        }
    }
    result.i=max;
    }else if (type ==DOUBLE)
    {
        double *tab=(double*)tabPoly;
        double max=tab[0];
        for(i=1;i<size;i++)
    {
        if(tab[i]>max)
        {
            max=tab[i];
        }
    }
    result.d=max;
    }
  return result;
}

//wkaźniki na void, unie

================================================================
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0
enum argumentType {INT,DOUBLE};


union polyType //moze przechowywac tylko 1 skaldowa w tej strukturze
{
    int i;
    double d;
};



union polyType getMax(void *tabPoly,unsigned int size, enum argumentType);
int main(void)
{
    int tabOfInts[]={3,2,1,5,6,4};
    double tabOfDoubles[]={3.3,2.2,1.1,5.5,6.6,4.4};
    union polyType result1, result2;
    
    result1=getMax(tabOfInts,6,INT);
    result2=getMax(tabOfDoubles,6,DOUBLE);
    printf("max=%d, max= %f",result1.i,result2.d);
    return EXIT_SUCCESS;
}

union polyType getMax(void *tabPoly,unsigned int size, enum argumentType type)
{
    int i;
    union polyType result;
    
    if (type ==INT)
    {
        int *tab=(int*)tabPoly;
        int max=tab[0];
        for(i=1;i<size;i++)
    {
        if(tab[i]>max)
        {
            max=tab[i];
        }
    }
    result.i=max;
    }else if (type ==DOUBLE)
    {
        double *tab=(double*)tabPoly;
        double max=tab[0];
        for(i=1;i<size;i++)
    {
        if(tab[i]>max)
        {
            max=tab[i];
        }
    }
    result.d=max;
    }
  return result;
}
============================================================
#include <stdio.h>
#include <stdlib.h>
#define EXIT_SUCCESS 0

#define maxLOOP(_max)\
        typeof(_max) max;\
        typeof(_max) *tab=(typeof(_max)*)tabPoly;\
        max=tab[0];\
        for(i=1;i<size;i++)\
    {\
        if(tab[i]>max)\
        {\
            max=tab[i];\
        }\
    }



enum argumentType {INT,DOUBLE};


union polyType //moze przechowywac tylko 1 skaldowa w tej strukturze
{
    int i;
    double d;
};

union polyType getMax(void *tabPoly,unsigned int size, enum argumentType);

int main(void)
{
    int tabOfInts[]={3,2,1,5,6,4};
    double tabOfDoubles[]={3.3,2.2,1.1,5.5,6.6,4.4};
    union polyType result1, result2;
    
    result1=getMax(tabOfInts,6,INT);
    result2=getMax(tabOfDoubles,6,DOUBLE);
    printf("max int=%d, max double= %f",result1.i,result2.d);
    return EXIT_SUCCESS;
}

union polyType getMax(void *tabPoly,unsigned int size, enum argumentType type)
{
    int i;
    union polyType result;
    int maxI;
    double maxD;
    
    if (type ==INT){
    maxLOOP(maxI)
    result.i=max;}
    else if (type ==DOUBLE){
       maxLOOP(maxD)
       result.d=max;}
  return result;
}
======================================================================================
program
dana jest tablica intow (10)
wywoływany z linni polecen, w zaleznosci od wywołania:
PROG min    -znajdx minimalny
PROG sort   -posortuj
PROG sort desc  -posortuj malejaca
PROG inRange min max   true/false true/false -wypisz wszystki wartosci mieszczace sie w zakresie indeksów, true jesli min wchodzi do zakresu, false nie wchodzi do zakresiw,

#include <stdio.h>

#define SIZE 10

enum bool {FALSE, TRUE};

int getMin(int tab[], int size);
void inRange(int tab[], int min, int max, enum bool minB, enum bool maxB);

int main() {
    int tab[] = {1, 3, 2, 5, 4, 7, 6, 9, 8, 0};
    int minrange= atoi(argv[2]);
    int maxrange= atoi(argv[3]);
    if(argc !=2 || argc !=4)
    {
        printf("Bad number of arguments");
        break;
    }
    if(argc ==2)
    {
        if(strcmp(argv[1],"min")==0)
        {
            getMin(tab, SIZE);
            printf("Minimalna wartość w tablicy: %d\n", min);
        }
        else{printf("ERROR");break;}
    }else{printf("ERROR");break;}
    
    if (argc==4)
    {
        if(strcmp(argv[1],"inRange")==0)
        {
            switch(minrange)
            {
            case TRUE:
                if(maxrange==TRUE)
                {
                    inRange(tab,minrange,maxrange,TRUE,TRUE);
                }
                if(maxrange==FALSE)
                {
                    inRange(tab,minrange,maxrange,TRUE,FALSE);
                }
            case FALSE:
                if(maxrange==TRUE)
                {
                    inRange(tab,minrange,maxrange,FALSE,TRUE);
                }
                if(maxrange==FALSE)
                {
                    inRange(tab,minrange,maxrange,FALSE,FALSE);
                }
            
            }
        }
        
        
    }else{printf("ERROR");break;}
    
    return 0;
}

int getMin(int tab[], int size) {
    int min = tab[0];
    for (int i = 1; i < size; i++) {
        if (tab[i] < min) {
            min = tab[i];
        }
    }
    return min;
}


void inRange(int tab[],int min, int max, enum bool minB, enum bool maxB)
{
    int start;
    int end;
    start=min;
    end=max;
    if(minB== FALSE)
    {
        start++;
    }
    if(maxB== TRUE)
    {
        end++;
    }
    for(int i=start;i<end;i++)
    {
        printf("%d ",tab[i]);
    }
}
=====================
wskazniki na funckje

#include <stdio.h>
void none(void){
    printf("None");
}
void foo1(void)
{
    printf("jestem funckja\n");
}
void foo2(void)
{
    printf("jestem funckja2\n");
}

int main(int argc, char **argv)
{
    void (*f[])(void)={none,foo1,foo2};
    if(argc>2)
    {
        argc=0;
    }
    
    f[argc]();
    return 0;
}
